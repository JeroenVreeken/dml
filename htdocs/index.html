<!DOCTYPE html>
<html>
<head>
	<title>dml_httpd</title>
	<meta charset="UTF-8"> 
</head>
<body style="background-color: white;">
<p>
dml_httpd works!
</p>
<div id="hello">No HELLO from server received.</div>

<div id="video_div" style="display: none;">
	<video style="border: 2px solid" id="video"></video>
	<button onclick="curcon.disconnect()">Disconnect</button>
</div>

<div id="dmlc2_div" style="display: none;">
	<div style="border: 2px solid" id="dmlc2_state"></div>
	<button onclick="curcon.disconnect()">Disconnect</button>
</div>

<div id = "routes"></div>


<script>

var DML = {
	PACKET:  {
		HELLO: 0,
		ROUTE: 1,
		DESCRIPTION: 2,
		CERTIFICATE: 3,
		HEADER: 4,
		CONNECT: 5,
		DISC: 6,

		REQ_DESCRIPTION: 34,
		REQ_CERTIFICATE: 35,
		REQ_HEADER: 36,
		REQ_REVERSE: 37,
		REQ_DISC: 38,
		
		DATA: 4096,
	},
	ID: {
		SIZE: 32,
	},
	SIG: {
		SIZE: ((256 * 2) / 8),
	},
	TIMESTAMP: {
		SIZE: 8,
	},
};

function char2hex(c)
{
	str = c.toString(16);
	while (str.length < 2)
		str = "0" + str;
	return str;
}

function data2str(data)
{
	var str = "";
	var i;
	
	for (i = 0; i < data.byteLength; i++) {
		var c = data.getUint8(i, false);

		if (!c)
			return str;
		str += String.fromCharCode(c);
	}
	return str;
}

function sha2str(data)
{
	if (data instanceof ArrayBuffer)
		data = new DataView(data);
	var i;
	var str = "";
	
	for (i = 0; i < 32; i++) {
		str += char2hex(data.getUint8(i));
	}
	
	return str;
}

/* compare two arraybuffers */
function ab_cmp(ab1, ab2)
{
	if (ab1.byteLength != ab2.byteLength)
		return true;
	
	var dv1 = new DataView(ab1);
	var dv2 = new DataView(ab2);
	var i;
	
	for (i = 0; i < ab1.byteLength; i++) {
		if (dv1.getUint8(i) != dv2.getUint8(i))
			return true;
	}
	
	return false;
}

/* copy contents of an array buffer into another */
function ab_copy(dst_ab, dst_off, src_ab, src_off, len)
{
	var dst = new DataView(dst_ab);
	var src = new DataView(src_ab);
	var i;
	
	for (i = 0; i < len; i++) {
		dst.setUint8(i + dst_off, src.getUint8(i + src_off));
	}
}

function dml()
{
	url = "ws://" + location.host;
	ws = new WebSocket(url);

	var dml_this = this;
	
	var packet_hello_cb = function(flags, ident) {}
	var packet_route_cb = function(hops, id) {}
	var packet_description_cb = function(id, version, bps, mime, name, alias, description) {}
	var packet_header_cb = function(header_id, header_data, header_sig) {}
	var packet_data_cb = function(data, timestamp, signature) {}
	var packet_certificate_cb = function(certificate_id, certificate_payload) {}

	ws.onmessage = function(msg) {
//		console.log("ws.onmessage: " + msg.data.byteLength);
	
		header = new DataView(msg.data, 0, 4);
		id = header.getUint16(0, false);
		len = header.getUint16(2, false);
		data = new DataView(msg.data, 4);
		pos = 4;
	
//		console.log("len: " + len + " id: " + id);

		switch(id) {
			case DML.PACKET.HELLO: {
				flags = data.getUint32(0, false);
				pos += 4;
				data = new DataView(msg.data, pos);

				ident = data2str(data);
				dml_this.packet_hello_cb(flags, ident);
				break;
			}
			case DML.PACKET.ROUTE: {
				hops = data.getUint8(32);
				route_id = msg.data.slice(pos, pos + DML.ID.SIZE);
				
				dml_this.packet_route_cb(hops, route_id);
				break;
			}
			case DML.PACKET.DESCRIPTION: {
				desc_id = msg.data.slice(pos, pos + DML.ID.SIZE);
				pos += DML.ID.SIZE;
				data = new DataView(msg.data, pos);
				desc_version = data.getUint8(0);
				desc_bps = data.getUint32(1, false);
				pos += 5;
				data = new DataView(msg.data, pos);
				desc_mime = data2str(data);
				pos += desc_mime.length + 1;
				data = new DataView(msg.data, pos);
				desc_name = data2str(data);
				pos += desc_name.length + 1;
				data = new DataView(msg.data, pos);
				desc_alias = data2str(data);
				pos += desc_alias.length + 1;
				data = new DataView(msg.data, pos);
				desc_description = data2str(data);
				pos += desc_description.length + 1;
				
				dml_this.packet_description_cb(
				    desc_id, desc_version, desc_bps, desc_mime, 
				    desc_name, desc_alias, desc_description);
				break;
			}
			case DML.PACKET.HEADER: {
				header_id = msg.data.slice(pos, pos + DML.ID.SIZE);
				header_data = msg.data.slice(pos + DML.ID.SIZE, pos + len - DML.SIG.SIZE);
				header_sig = msg.data.slice(pos + len - DML.SIG.SIZE, pos + len);
				
				dml_this.packet_header_cb(
				    header_id, header_data, header_sig);
				break;
			}
			case DML.PACKET.CERTIFICATE: {
				certificate_id = msg.data.slice(pos, pos + DML.ID.SIZE);
				certificate_payload = msg.data.slice(pos + DML.ID.SIZE, pos + len);
				
				dml_this.packet_certificate_cb(
				    certificate_id, certificate_payload);
				break;
			}
			default: {
				if (id == connected_data_id) {
					data = msg.data.slice(pos, pos + len - DML.SIG.SIZE - DML.TIMESTAMP.SIZE);
					signature = msg.data.slice(pos + len - DML.SIG.SIZE, pos + len);
					timestampdata = new DataView(msg.data, pos + len - DML.SIG.SIZE - DML.TIMESTAMP.SIZE);
					timestamp = timestampdata.getUint32(0, false) << 32;
					timestamp += timestampdata.getUint32(4, false);
					
					dml_this.packet_data_cb(data, timestamp, signature);
				}
			}
		}
	}

	ws.onopen = function(event) {
		console.log("ws.onopen()");
		ws.binaryType = "arraybuffer";
	}

	ws.onclose = function(event) {
		console.log("ws.onclose(): " + event.code + ", " + event.reason);
	}

	ws.onerror = function(event) {
		console.log("ws.onerror(): " + event.data);
	}
	
	this.send = function dml_connection_send(id, payload_arraybuffer) {
		data = new ArrayBuffer(payload_arraybuffer.byteLength + 4);
		dataview = new DataView(data);
		dataview.setUint16(0, id, false);
		dataview.setUint16(2, payload_arraybuffer.byteLength, false);
		
		payloadview = new DataView(payload_arraybuffer);
		
		var i;
		for (i = 0; i < payload_arraybuffer.byteLength; i++) {
			dataview.setUint8(4 + i, payloadview.getUint8(i));
		}
		ws.send(data);
	}
	
	this.send_req_description = function dml_packet_send_req_description(id) {
		dml_this.send(DML.PACKET.REQ_DESCRIPTION, id);
	}
	this.send_req_header = function dml_packet_send_req_header(id) {
		dml_this.send(DML.PACKET.REQ_HEADER, id);
	}
	this.send_req_disc = function dml_packet_send_req_disc(id) {
		dml_this.send(DML.PACKET.REQ_DISC, id);
	}
	this.send_req_certificate = function dml_packet_send_req_certificate(id) {
		dml_this.send(DML.PACKET.REQ_CERTIFICATE, id);
	}
	this.send_connect = function dml_packet_send_connect(id, packet_id) {
		data = new ArrayBuffer(id.byteLength + 2);
		ab_copy(data, 0, id, 0, DML.ID.SIZE);
		dataview = new DataView(data);
		dataview.setUint16(id.byteLength, packet_id, false);
		dml_this.send(DML.PACKET.CONNECT, data);
	}
}


var routes = new Array();

function update_routes()
{
	var i;
	str = "";
	
	for (i = 0; i < routes.length; i++) {
		var can_play_mse = false;
		var can_play_dml = false;
		
		str += "<pre>";
		str += "id: " + sha2str(routes[i].id) + " hops: " + routes[i].hops + "\n";
		if (routes[i].description) {
			str += "\tbps:\t" + routes[i].description.bps + "\n";
			str += "\tmime:\t" + routes[i].description.mime + "\n";
			str += "\tname:\t" + routes[i].description.name + "\n";
			str += "\talias:\t" + routes[i].description.alias + "\n";
			str += "\tdescription:\t" + routes[i].description.description + "\n";
			can_play_mse = mse.supported(routes[i].description.mime);
			can_play_dml = dmlc2.supported(routes[i].description.mime);
		}
		if (routes[i].certificate) {
			str += "\tcertificate length:\t" + routes[i].certificate.data.byteLength;
		}
		str += "</pre>";

		if (can_play_mse) {
			str += "<button onclick=\"mse.connect(" + i + ")\">Connect</button>";
		} else if (can_play_dml) {
			str += "<button onclick=\"dmlc2.connect(" + i + ")\">Connect</button>";
		} else {
			str += "Mime type not supported by browser\n";
		}
	}
	document.getElementById("routes").innerHTML = str;
}

connection = new dml();

function eth_ar()
{
	var eth_ar_this = this;
	
	this.alnum2code = [
		'0', '1', '2', '3', '4', '5', '6', '7', '8', '9',
		'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M',
		'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 
		''
	];

	
	this.call = function (mac) {
		var dv = new DataView(mac);
		
		var multicast = dv.getUint8(0) & 0x01;
		var ssid = (dv.getUint8(0) & 0x3c) >> 2;
		var macc = (dv.getUint8(0) & 0xc0) >> 6;

		/* Do not use binary operators here!
		   They are limited to 32bit in this poor excuse for a language... */
		macc *= 256;
		macc += dv.getUint8(1);
		macc *= 256;
		macc += dv.getUint8(2);
		macc *= 256;
		macc += dv.getUint8(3);
		macc *= 256;
		macc += dv.getUint8(4);
		macc *= 256;
		macc += dv.getUint8(5);
		
		var i;
		var callsign = "";
		for (i = 0; i < 8; i++) {
			var c = (macc % 37)  & 0x3f;
			callsign += eth_ar_this.alnum2code[c];
			macc /= 37;
		}
		callsign += "-" + ssid;
		
		if (multicast) {
			callsign = "MULTICAST";
		}
		
		return callsign;
	}
}

var eth_ar = new eth_ar();

connected = false;
connected_id = null;
connected_data_id = DML.PACKET.DATA;
connected_timestamp = 0;

function prep_connect(id)
{
	if (connected && ab_cmp(routes[id].id, connected_id)) {
		curcon.disconnect();
	}
	
	connected = true;
	connected_id = routes[id].id;
}

function do_connect(id)
{
	connection.send_req_header(connected_id);
}

function disconnect()
{
	if (connected) {
		connection.send_req_disc(connected_id);
		connected_data_id++;
		connected = false;
	}
}

function mse()
{
	var mediaSource = new MediaSource();
	var sourceBuffer;
	var video = document.getElementById("video");

	var mse_this = this;

	this.supported = function supported(mime) {
		return MediaSource.isTypeSupported(mime);	
	}

	this.disconnect = function mse_disconnect() 
	{
		disconnect();
		video.pause();
//			video.src = "";
//			video.play();
		document.getElementById("video_div").style.display = "none";
	}

	this.connect = function mse_connect(id) 
	{
		document.getElementById("video_div").style.display = "block";

		prep_connect(id);
		curcon = mse_this;
		
		video.src = URL.createObjectURL(mediaSource);
		video.play();
		
		console.log("mediaSource.readyState: " + mediaSource.readyState);
		mediaSource.addEventListener('sourceopen', sourceOpen_mse);
	}

	function sourceOpen_mse (_) {
		console.log("mediaSource.readyState: " + mediaSource.readyState);

		sourceBuffer = mediaSource.addSourceBuffer("video/webm");

		do_connect(connected_id);
		console.log("Requested header");
	};
	
	this.data = function mse_data(newdata) {
		sourceBuffer.appendBuffer(newdata);
		if (video.buffered.length) {
			if (video.buffered.start(0) > video.currentTime)
				video.currentTime = video.buffered.start(0);
		}
	}
}

mse = new mse();

function dmlc2()
{
	var dmlc2_this = this;
	
	this.supported = function supported(mime) {
		return mime == "audio/dml-codec2";
	}
	
	this.connect = function dmlc2_connect(id) {
		document.getElementById("dmlc2_div").style.display = "block";
		document.getElementById("dmlc2_state").innerHTML = "Connect send";

		prep_connect(id);
		curcon = dmlc2_this;

		do_connect(connected_id);
	}
	this.disconnect = function dmlc2_disconnect() 
	{
		disconnect();
		document.getElementById("dmlc2_div").style.display = "none";
	}
	
	var state = false;
	var mode = -1;
	var callsign = "?";
	
	this.data = function dmlc2_data(newdata) {
		if (data.byteLength >= 8) {
			var dv = new DataView(newdata);
			
			var newstate = dv.getUint8(7) & 0x1;
			var newmode = dv.getUint8(6);
			var newcallsign = eth_ar.call(newdata);

			if (newstate != state || newmode != mode || callsign != newcallsign) {
				var str = "state: " + newstate + " mode: " + newmode + " callsign: " + newcallsign;

				document.getElementById("dmlc2_state").innerHTML = str;
				    
				state = newstate;
				mode = newmode;
			}
		}
	}
}

dmlc2 = new dmlc2();

var curcon;

connection.packet_hello_cb = function(flags, ident) {
	document.getElementById("hello").innerHTML = "Server identity: " + ident + "<br>Server flags: " + flags;
}

connection.packet_route_cb = function(hops, id) {
	var i;
	
	for(i = 0; i < routes.length; i++) {
		if (!ab_cmp(routes[i].id, id))
			break;
	}
	routes[i] = {};
	routes[i].id = id;
	routes[i].hops = hops;
	
	/* remove route? */
	if (hops == 255) {
		routes.splice(i, 1);
	} else {
		/* already got a description? */
		if (!routes[i].description)
			connection.send_req_description(id);
		if (!routes[i].certificate)
			connection.send_req_certificate(id);
	}
	
	update_routes();
}

connection.packet_description_cb = function(id, version, bps, mime, name, alias, description) {
	var i;
	
	for (i = 0; i < routes.length; i++) {
		if (!ab_cmp(routes[i].id, id)) {
			routes[i].description = {};
			routes[i].description.version = version;
			routes[i].description.bps = bps;
			routes[i].description.mime = mime;
			routes[i].description.name = name;
			routes[i].description.alias = alias;
			routes[i].description.description = description;
		}
	}
	
	update_routes();
}

connection.packet_certificate_cb = function(id, cert) {
	var i;
	
	for (i = 0; i < routes.length; i++) {
		if (!ab_cmp(routes[i].id, id)) {
			routes[i].certificate = {};
			routes[i].certificate.data = cert;
		}
	}
		
	update_routes();
}


connection.packet_header_cb = function(header_id, header_data, header_sig) {
	console.log("header " + header_id.byteLength + " " + header_data.byteLength + " " + header_sig.byteLength);
	if (!ab_cmp(connected_id, header_id)) {
		console.log("Send connect");
		connection.send_connect(connected_id, connected_data_id);

		if (header_data.byteLength) {
			curcon.data(header_data);
		}
	}
}


connection.packet_data_cb = function(data, timestamp, signature) {
	var i;
	if (timestamp <= connected_timestamp) {
		console.log("timestamp invalid");
	}

	curcon.data(data);
}

</script>
</body>

</html>
