<!DOCTYPE html>
<html>
<head>
	<title>dml_httpd</title>
	<meta charset="UTF-8"> 
</head>
<body style="background-color: white;">
<p>
dml_httpd works!
</p>
<div id="hello">No HELLO from server received.</div>

<div id="video_div" style="display: none;">
	<video style="border: 2px solid" id="video"></video>
	<button onclick="curcon.disconnect()">Disconnect</button>
</div>

<div id="dmlc2_div" style="display: none;">
	<div style="border: 2px solid" id="dmlc2_state"></div>
	<button onclick="curcon.disconnect()">Disconnect</button>
</div>

<div id="fprs_div" style="display: none;">
	<div style="border: 2px solid" id="fprs_state"></div>
	<button onclick="curcon.disconnect()">Disconnect</button>
</div>

<div id = "routes"></div>


<script>

var DML = {
	PACKET:  {
		HELLO: 0,
		ROUTE: 1,
		DESCRIPTION: 2,
		CERTIFICATE: 3,
		HEADER: 4,
		CONNECT: 5,
		DISC: 6,

		REQ_DESCRIPTION: 34,
		REQ_CERTIFICATE: 35,
		REQ_HEADER: 36,
		REQ_REVERSE: 37,
		REQ_DISC: 38,
		
		DATA: 4096,
	},
	ID: {
		SIZE: 32,
	},
	SIG: {
		SIZE: ((256 * 2) / 8),
	},
	TIMESTAMP: {
		SIZE: 8,
	},
};

var FPRS = {
	ELEMENT: {
		/* length limited ,to 7 */
		ERROR: -1,
		POSITION: 0,
		CALLSIGN: 1,
		SYMBOL: 2,
		ALTITUDE: 3,
		VECTOR: 4,
		/* length limited to 255 */
		OBJECTNAME: 16,
		COMMENT: 17,
		REQUEST: 18,
		DESTINATION: 19,
		TIMESTAMP: 20,
		DMLSTREAM: 21,
		DMLASSOC: 22,
	}
};

function char2hex(c)
{
	str = c.toString(16);
	while (str.length < 2)
		str = "0" + str;
	return str;
}

function data2str(data, length, offset)
{
	var str = "";
	var i;
	var l = typeof length !== 'undefined' ? length : data.byteLength;
	var o = typeof offset !== 'undefined' ? offset : 0;
	
	for (i = o; i < l; i++) {
		var c = data.getUint8(i, false);

		if (!c)
			return str;
		str += String.fromCharCode(c);
	}
	return str;
}

function sha2str(data)
{
	if (data instanceof ArrayBuffer)
		data = new DataView(data);
	var i;
	var str = "";
	
	for (i = 0; i < 32; i++) {
		str += char2hex(data.getUint8(i));
	}
	
	return str;
}

/* compare two arraybuffers */
function ab_cmp(ab1, ab2)
{
	if (ab1.byteLength != ab2.byteLength)
		return true;
	
	var dv1 = new DataView(ab1);
	var dv2 = new DataView(ab2);
	var i;
	
	for (i = 0; i < ab1.byteLength; i++) {
		if (dv1.getUint8(i) != dv2.getUint8(i))
			return true;
	}
	
	return false;
}

/* copy contents of an array buffer into another */
function ab_copy(dst_ab, dst_off, src_ab, src_off, len)
{
	var dst = new DataView(dst_ab);
	var src = new DataView(src_ab);
	var i;
	
	for (i = 0; i < len; i++) {
		dst.setUint8(i + dst_off, src.getUint8(i + src_off));
	}
}

function dml()
{
	url = "ws://" + location.host;
	ws = new WebSocket(url);

	var dml_this = this;
	
	var packet_hello_cb = function(flags, ident) {}
	var packet_route_cb = function(hops, id) {}
	var packet_description_cb = function(id, version, bps, mime, name, alias, description) {}
	var packet_header_cb = function(header_id, header_data, header_sig) {}
	var packet_data_cb = function(data, timestamp, signature) {}
	var packet_certificate_cb = function(certificate_id, certificate_payload) {}

	ws.onmessage = function(msg) {
//		console.log("ws.onmessage: " + msg.data.byteLength);
	
		header = new DataView(msg.data, 0, 4);
		id = header.getUint16(0, false);
		len = header.getUint16(2, false);
		data = new DataView(msg.data, 4);
		pos = 4;
	
//		console.log("len: " + len + " id: " + id);

		switch(id) {
			case DML.PACKET.HELLO: {
				flags = data.getUint32(0, false);
				pos += 4;
				data = new DataView(msg.data, pos);

				ident = data2str(data);
				dml_this.packet_hello_cb(flags, ident);
				break;
			}
			case DML.PACKET.ROUTE: {
				hops = data.getUint8(32);
				route_id = msg.data.slice(pos, pos + DML.ID.SIZE);
				
				dml_this.packet_route_cb(hops, route_id);
				break;
			}
			case DML.PACKET.DESCRIPTION: {
				desc_id = msg.data.slice(pos, pos + DML.ID.SIZE);
				pos += DML.ID.SIZE;
				data = new DataView(msg.data, pos);
				desc_version = data.getUint8(0);
				desc_bps = data.getUint32(1, false);
				pos += 5;
				data = new DataView(msg.data, pos);
				desc_mime = data2str(data);
				pos += desc_mime.length + 1;
				data = new DataView(msg.data, pos);
				desc_name = data2str(data);
				pos += desc_name.length + 1;
				data = new DataView(msg.data, pos);
				desc_alias = data2str(data);
				pos += desc_alias.length + 1;
				data = new DataView(msg.data, pos);
				desc_description = data2str(data);
				pos += desc_description.length + 1;
				
				dml_this.packet_description_cb(
				    desc_id, desc_version, desc_bps, desc_mime, 
				    desc_name, desc_alias, desc_description);
				break;
			}
			case DML.PACKET.HEADER: {
				header_id = msg.data.slice(pos, pos + DML.ID.SIZE);
				header_data = msg.data.slice(pos + DML.ID.SIZE, pos + len - DML.SIG.SIZE);
				header_sig = msg.data.slice(pos + len - DML.SIG.SIZE, pos + len);
				
				dml_this.packet_header_cb(
				    header_id, header_data, header_sig);
				break;
			}
			case DML.PACKET.CERTIFICATE: {
				certificate_id = msg.data.slice(pos, pos + DML.ID.SIZE);
				certificate_payload = msg.data.slice(pos + DML.ID.SIZE, pos + len);
				
				dml_this.packet_certificate_cb(
				    certificate_id, certificate_payload);
				break;
			}
			default: {
				if (id == connected_data_id) {
					data = msg.data.slice(pos, pos + len - DML.SIG.SIZE - DML.TIMESTAMP.SIZE);
					signature = msg.data.slice(pos + len - DML.SIG.SIZE, pos + len);
					timestampdata = new DataView(msg.data, pos + len - DML.SIG.SIZE - DML.TIMESTAMP.SIZE);
					timestamp = timestampdata.getUint32(0, false) << 32;
					timestamp += timestampdata.getUint32(4, false);
					
					dml_this.packet_data_cb(data, timestamp, signature);
				}
			}
		}
	}

	ws.onopen = function(event) {
		console.log("ws.onopen()");
		ws.binaryType = "arraybuffer";
	}

	ws.onclose = function(event) {
		console.log("ws.onclose(): " + event.code + ", " + event.reason);
	}

	ws.onerror = function(event) {
		console.log("ws.onerror(): " + event.data);
	}
	
	this.send = function dml_connection_send(id, payload_arraybuffer) {
		data = new ArrayBuffer(payload_arraybuffer.byteLength + 4);
		dataview = new DataView(data);
		dataview.setUint16(0, id, false);
		dataview.setUint16(2, payload_arraybuffer.byteLength, false);
		
		payloadview = new DataView(payload_arraybuffer);
		
		var i;
		for (i = 0; i < payload_arraybuffer.byteLength; i++) {
			dataview.setUint8(4 + i, payloadview.getUint8(i));
		}
		ws.send(data);
	}
	
	this.send_req_description = function dml_packet_send_req_description(id) {
		dml_this.send(DML.PACKET.REQ_DESCRIPTION, id);
	}
	this.send_req_header = function dml_packet_send_req_header(id) {
		dml_this.send(DML.PACKET.REQ_HEADER, id);
	}
	this.send_req_disc = function dml_packet_send_req_disc(id) {
		dml_this.send(DML.PACKET.REQ_DISC, id);
	}
	this.send_req_certificate = function dml_packet_send_req_certificate(id) {
		dml_this.send(DML.PACKET.REQ_CERTIFICATE, id);
	}
	this.send_connect = function dml_packet_send_connect(id, packet_id) {
		data = new ArrayBuffer(id.byteLength + 2);
		ab_copy(data, 0, id, 0, DML.ID.SIZE);
		dataview = new DataView(data);
		dataview.setUint16(id.byteLength, packet_id, false);
		dml_this.send(DML.PACKET.CONNECT, data);
	}
}


var routes = new Array();

function update_routes()
{
	var i;
	routes_str = "";
	
	for (i = 0; i < routes.length; i++) {
		var can_play_mse = false;
		var can_play_dml = false;
		var can_play_fprs = false;
	
		var shastr = sha2str(routes[i].id);	
		var ui_id = shastr;
		if (routes[i].description) {
			ui_id = routes[i].description.name;
			if (routes[i].description.alias)
				ui_id += " (" + routes[i].description.alias + ")";
			can_play_mse = mse.supported(routes[i].description.mime);
			can_play_dml = dmlc2.supported(routes[i].description.mime);
			can_play_fprs = fprs.supported(routes[i].description.mime);
		}
		var str = "";
		
		str += "<div style='background-color:yellow;margin: 1px 1px 1px 30px; display: none' id='desc_" + shastr + "'>";
		if (routes[i].description) {
			str += "\tdescription:\t" + routes[i].description.description + "<br>";
			str += "\tbps:\t" + routes[i].description.bps + "<br>";
			str += "\tmime:\t" + routes[i].description.mime + "<br>";
			str += "\tname:\t" + routes[i].description.name + "<br>";
			str += "\talias:\t" + routes[i].description.alias + "<br>";
		}
		if (routes[i].certificate) {
			str += "\tcertificate length:\t" + routes[i].certificate.data.byteLength + "<br>";
		}
		str += "\tid:\t" + shastr + "<br>";
		str += "\thops:\t" + routes[i].hops + "<br>";
		str += "</div>";

		if (can_play_mse) {
			button_str = "<button onclick=\"mse.connect(" + i + ")\">Connect & Play</button>";
		} else if (can_play_dml) {
			button_str = "<button onclick=\"dmlc2.connect(" + i + ")\">Connect & monitor state</button>";
		} else if (can_play_fprs) {
			button_str = "<button onclick=\"fprs.connect(" + i + ")\">Connect & monitor FPRS frames</button>";
		} else {
			button_str = "Mime type not supported by browser\n";
		}
		id_str = "<div width='100%' style='background-color:lightblue;'>";
		id_str += "<button onclick=\"div_toggle('desc_" + shastr + "')\">i</button>";
		id_str += ui_id + " " + button_str;
		id_str += str;
		id_str += "</div>";
		
		routes_str += id_str;
	}
	document.getElementById("routes").innerHTML = routes_str;
}

function div_toggle(id)
{
	var dis = document.getElementById(id).style.display;
	
	console.log("toggle " + dis);
	
	if (dis == "block")
		dis = "none";
	else
		dis = "block";
	document.getElementById(id).style.display = dis;
}

connection = new dml();

function eth_ar()
{
	var eth_ar_this = this;
	
	this.alnum2code = [
		'0', '1', '2', '3', '4', '5', '6', '7', '8', '9',
		'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M',
		'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 
		''
	];

	
	this.call = function (mac, offset) {
		var offset = typeof offset !== 'undefined' ? offset : 0;
		var dv = new DataView(mac, offset);
		
		var multicast = dv.getUint8(0) & 0x01;
		var ssid = (dv.getUint8(0) & 0x3c) >> 2;
		var macc = (dv.getUint8(0) & 0xc0) >> 6;

		/* Do not use binary operators here!
		   They are limited to 32bit in this poor excuse for a language... */
		macc *= 256;
		macc += dv.getUint8(1);
		macc *= 256;
		macc += dv.getUint8(2);
		macc *= 256;
		macc += dv.getUint8(3);
		macc *= 256;
		macc += dv.getUint8(4);
		macc *= 256;
		macc += dv.getUint8(5);
		
		var i;
		var callsign = "";
		for (i = 0; i < 8; i++) {
			var c = (macc % 37)  & 0x3f;
			callsign += eth_ar_this.alnum2code[c];
			macc /= 37;
		}
		callsign += "-" + ssid;
		
		if (multicast) {
			callsign = "MULTICAST";
		}
		
		return callsign;
	}
}

var eth_ar = new eth_ar();

connected = false;
connected_id = null;
connected_data_id = DML.PACKET.DATA;
connected_timestamp = 0;

function prep_connect(id)
{
	if (connected && ab_cmp(routes[id].id, connected_id)) {
		curcon.disconnect();
	}
	
	connected = true;
	connected_id = routes[id].id;
}

function do_connect(id)
{
	connection.send_req_header(id);
}

function disconnect()
{
	if (connected) {
		connection.send_req_disc(connected_id);
		connected_data_id++;
		connected = false;
	}
}

function mse()
{
	var mediaSource = new MediaSource();
	var sourceBuffer;
	var video = document.getElementById("video");

	var mse_this = this;

	this.supported = function supported(mime) {
		return MediaSource.isTypeSupported(mime);	
	}

	this.disconnect = function mse_disconnect() 
	{
		disconnect();
		video.pause();
//			video.src = "";
//			video.play();
		document.getElementById("video_div").style.display = "none";
	}

	this.connect = function mse_connect(id) 
	{
		document.getElementById("video_div").style.display = "block";

		prep_connect(id);
		curcon = mse_this;
		
		video.src = URL.createObjectURL(mediaSource);
		video.play();
		
		console.log("mediaSource.readyState: " + mediaSource.readyState);
		mediaSource.addEventListener('sourceopen', sourceOpen_mse);
	}

	function sourceOpen_mse (_) {
		console.log("mediaSource.readyState: " + mediaSource.readyState);

		sourceBuffer = mediaSource.addSourceBuffer("video/webm");

		do_connect(connected_id);
		console.log("Requested header");
	};
	
	this.data = function mse_data(newdata) {
		sourceBuffer.appendBuffer(newdata);
		if (video.buffered.length) {
			if (video.buffered.start(0) > video.currentTime)
				video.currentTime = video.buffered.start(0);
		}
	}
}

mse = new mse();

function fprs_element(eltype, elsize, eldataview, eloff)
{
	var type = eltype;
	var size = elsize;
	var dataview = new DataView(eldataview.buffer, eldataview.byteOffset + eloff, elsize);

	this.tostring = function fprs_element_tostring() {
		var str = "";

		switch (type) {
			case FPRS.ELEMENT.POSITION:
				str+= "POSITION: ";
	
				var fixed = dataview.getUint8(3) & 0x08;
				var longitude = 0;
				var latitude = 0;

				longitude  = dataview.getUint8(0) << 20;
				longitude |= dataview.getUint8(1) << 12;
				longitude |= dataview.getUint8(2) << 4;
				longitude |= (dataview.getUint8(3) & 0xf0) >> 4;
				if (longitude & 0x08000000) {
					longitude ^= 0x0fffffff;
					longitude += 1;
					longitude = - longitude;
				}
				longitude = (longitude * 180.0) / 134217728;
				if (longitude > 180)
					longitude -= 360;

				latitude  = (dataview.getUint8(3) & 0x07) << 24;
				latitude |= dataview.getUint8(4) << 16;
				latitude |= dataview.getUint8(5) << 8;
				latitude |= dataview.getUint8(6);

				if (latitude & 0x04000000) {
					latitude ^= 0x07ffffff;
					latitude += 1;
					latitude = - latitude;
				}
				latitude = (latitude * 90.0) / 67108864;
				
				str += longitude + " " + latitude;
				if (fixed)
					str += " Fixed";
				
				break;
			case FPRS.ELEMENT.CALLSIGN:
				str+= "CALLSIGN: ";
				str+= eth_ar.call(dataview.buffer, dataview.byteOffset);
				break;
			case FPRS.ELEMENT.SYMBOL:
				str+= "SYMBOL: ";
				var c0 = dataview.getUint8(0, false);
				var c1 = dataview.getUint8(1, false);
				str += String.fromCharCode(c0);
				str += String.fromCharCode(c1);
				break;
			case FPRS.ELEMENT.ALTITUDE:
				str+= "ALTITUDE";
				break;
			case FPRS.ELEMENT.VECTOR:
				str+= "VECTOR";
				break;
			case FPRS.ELEMENT.OBJECTNAME:
				str+= "OBJECTNAME";
				break;
			case FPRS.ELEMENT.COMMENT:
				str+= "COMMENT: ";
				str+= data2str(dataview);
				break;
			case FPRS.ELEMENT.REQUEST:
				str+= "REQUEST";
				break;
			case FPRS.ELEMENT.DESTINATION:
				str+= "DESTINATION";
				break;
			case FPRS.ELEMENT.TIMESTAMP:
				str+= "TIMESTAMP";
				break;
			case FPRS.ELEMENT.DMLSTREAM:
				str+= "DMLSTREAM: ";
				str+= data2str(dataview);
				break;
			case FPRS.ELEMENT.DMLASSOC:
				str+= "DMLASSOC: ";
				str+= data2str(dataview);
				break;
		}
		
		return str;
	}
}

function fprs_frame(fprs_arraybuffer)
{
	var dv = new DataView(fprs_arraybuffer);
	
	this.elements = new Array();
	var i;
	
	for (i = 0; i < dv.byteLength;) {
		var left = dv.byteLength - i;
		var el0 = dv.getUint8(i+0);
		var el_size_total = 1;
		var el_size = 0;
		var el_start = i;
		var el_type = FPRS.ELEMENT.ERROR;
		var el_off;
		
		if ((el0 & 0x80) == 0) {
			el_size = el0 & 0x07;
			el_size_total = el_size + 1;
			el_type = (el0 & 0x78) >> 3;
			el_off = i + 1;
		} else if (left >= 2) {
			var el1 = dv.getUint8(i+1);
			
			if ((el0 & 0xc0) == 0x80) {
				el_size = el1;
				el_size_total = el_size + 2;
				el_type = el0 & 0x3f;
				el_off = i + 2;
			} else if (left >= 3) {
				var el2 = dv.getUint8(i+2);
				
				el_size = el2;
				el_size_total = el_size + 3;
				el_type = el1 + ((el0 & 0x1f) << 8);
				el_off = i + 3;
			}
		}
		
		if (el_size_total && el_size_total <= left) {
			/* Got an element */
			
			this.elements.push(new fprs_element(el_type, el_size, dv, el_off));
		}
		
		i += el_size_total;
	}
}

function fprs()
{
	var fprs_this = this;
	
	this.supported = function supported(mime) {
		return mime == "application/fprs";
	}
	var ui_name;
	
	this.connect = function fprs_connect(id) {
		prep_connect(id);
		curcon = fprs_this;

		if (routes[id].description) {
			fprs_this.ui_name = routes[id].description.name;
		} else {
			fprs_this.ui_name = "";
		}

		document.getElementById("fprs_div").style.display = "block";
		document.getElementById("fprs_state").innerHTML = fprs_this.ui_name + ": Connect send";

		do_connect(connected_id);
	}
	this.disconnect = function fprs_disconnect() 
	{
		disconnect();
		document.getElementById("fprs_div").style.display = "none";
	}

	this.data = function fprs_data(newdata) {
		frame = new fprs_frame(newdata);
		
		var str;
		
		str = "";
		var i;
		for (i = 0; i < frame.elements.length; i++) {
			str += frame.elements[i].tostring() + " ";
		}
		str+= "<br>";
		
		fprs_this.update_ui(str);
	}
	
	this.update_ui = function (length) {
		var str = fprs_this.ui_name + ": " + length +"\n";

		document.getElementById("fprs_state").innerHTML += str;
	}
}

fprs = new fprs();

function dmlc2()
{
	var dmlc2_this = this;
	
	this.supported = function supported(mime) {
		return mime == "audio/dml-codec2";
	}
	
	var ui_name;
	
	this.connect = function dmlc2_connect(id) {
		prep_connect(id);
		curcon = dmlc2_this;

		if (routes[id].description) {
			dmlc2_this.ui_name = routes[id].description.name;
		} else {
			dmlc2_this.ui_name = "";
		}

		document.getElementById("dmlc2_div").style.display = "block";
		document.getElementById("dmlc2_state").innerHTML = dmlc2_this.ui_name + ": Connect send";

		do_connect(connected_id);
	}
	this.disconnect = function dmlc2_disconnect() 
	{
		disconnect();
		document.getElementById("dmlc2_div").style.display = "none";
	}
	
	var state = false;
	var mode = -1;
	var callsign = "?";
	var timeout_var = false;
	
	this.data = function dmlc2_data(newdata) {
		if (data.byteLength >= 8) {
			var dv = new DataView(newdata);
			
			var newstate = dv.getUint8(7) & 0x1;
			var newmode = dv.getUint8(6);
			var newcallsign = eth_ar.call(newdata);

			if (dmlc2_this.timeout_var) {
				clearTimeout(dmlc2_this.timeout_var);
				dmlc2_this.timeout_var = false;
			}

			dmlc2_this.update_ui(newstate, newmode, newcallsign);
			
			if (newstate) {
				dmlc2_this.timeout_var = setTimeout(this.tx_timeout, 100);
			}
		}
	}
	
	this.tx_timeout = function () {
		dmlc2_this.timeout_var = false;
		
		dmlc2_this.update_ui(0, 0, "-");
	}
	
	this.update_ui = function (newstate, newmode, newcallsign) {
		if (newstate != dmlc2_this.state || newmode != dmlc2_this.mode || dmlc2_this.callsign != newcallsign) {
			var str = dmlc2_this.ui_name + ": state: " + newstate + " mode: " + newmode + " callsign: " + newcallsign;

			document.getElementById("dmlc2_state").innerHTML = str;
				    
			dmlc2_this.state = newstate;
			dmlc2_this.mode = newmode;
			dmlc2_this.callsign = newcallsign;
		}	
	}
}

dmlc2 = new dmlc2();

var curcon;

connection.packet_hello_cb = function(flags, ident) {
	document.getElementById("hello").innerHTML = "Server identity: " + ident + "<br>Server flags: " + flags;
}

connection.packet_route_cb = function(hops, id) {
	var i;
	
	for(i = 0; i < routes.length; i++) {
		if (!ab_cmp(routes[i].id, id))
			break;
	}
	routes[i] = {};
	routes[i].id = id;
	routes[i].hops = hops;
	
	/* remove route? */
	if (hops == 255) {
		routes.splice(i, 1);
	} else {
		/* already got a description? */
		if (!routes[i].description)
			connection.send_req_description(id);
		if (!routes[i].certificate)
			connection.send_req_certificate(id);
	}
	
	update_routes();
}

connection.packet_description_cb = function(id, version, bps, mime, name, alias, description) {
	var i;
	
	for (i = 0; i < routes.length; i++) {
		if (!ab_cmp(routes[i].id, id)) {
			routes[i].description = {};
			routes[i].description.version = version;
			routes[i].description.bps = bps;
			routes[i].description.mime = mime;
			routes[i].description.name = name;
			routes[i].description.alias = alias;
			routes[i].description.description = description;
		}
	}
	
	update_routes();
}

connection.packet_certificate_cb = function(id, cert) {
	var i;
	
	for (i = 0; i < routes.length; i++) {
		if (!ab_cmp(routes[i].id, id)) {
			routes[i].certificate = {};
			routes[i].certificate.data = cert;
		}
	}
		
	update_routes();
}


connection.packet_header_cb = function(header_id, header_data, header_sig) {
	console.log("header " + header_id.byteLength + " " + header_data.byteLength + " " + header_sig.byteLength);
	if (!ab_cmp(connected_id, header_id)) {
		console.log("Send connect");
		connection.send_connect(connected_id, connected_data_id);

		if (header_data.byteLength) {
			curcon.data(header_data);
		}
	}
}


connection.packet_data_cb = function(data, timestamp, signature) {
	var i;
	if (timestamp <= connected_timestamp) {
		console.log("timestamp invalid");
	}

	curcon.data(data);
}

</script>
</body>

</html>
